# 本次修改说明

1. 将所有的平均池化均用核为`1`的`一维卷积`

    `nn.Conv2d(seq_len, 1, kernel_size=1)`  
    `nn.AdativePool3d()`

2. 通过一维卷积的办法，将多阶向量参与反向传播过程，包括`交叉熵`和`三元组损失函数`。

    后期我想引进**`Center Loss`** 参与权重向量的计算， 这可能是一个涨点的办法
    
# 本次实验可能存在的问题

    我没有对阶合并卷积做参数的初始化。但需要注意的是，在我们的代码中，尤其是`nn.ModuleList`,直接使用
    `.apply(weight_init_kaiming)`是否真正作用到了每个函数中了。    


# 实验结果

|epoch|mAP|Rank1|Rank5|
|:--:|:--:|:--:|:--:|
|520|$\color{red}80.7$|$\color{red}87.2$|$\color{red}95.3$|
|480|80.6|86.8|95.2|
|440|80.8|87.1|95.3|
|400|80.5|86.9|94.9|
|360|80.4|86.7|95.1|

|epoch|mAP|Rank1|Rank5|
|:--:|:--:|:--:|:--:|
|520|80.3|$\color{red}87.3$|95.0|
|480|80.1|87.1|95.1|
|440|80.1|87.0|95.2|
|400|$\color{red}80.8$|86.0|$\color{red}95.4$|